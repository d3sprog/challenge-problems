We thank the anonymous reviewers for their helpful comments. In the following we summarize the changes we have made in response to those comments.

Reviewer A
-----------------------------------------------------------------


We rewrote the introduction to remove statements of opinion and to clarify that the goal of our research on schema change is to speed feedback loops in software development. Ultimately that is a value judgement, but we believe that value is important to a substantial community of researchers and practitioners.

Section 2 has been revised to remove the claim of providing a conceptial framework. Instead we define multiple dimensions of schema change that are used throughout the sequel to figuratively constrast different problems.


Reviewer B
-----------------------------------------------------------------
As suggested, the Literature Review was converted into a more appropriately named Related Work section.




Reviewer A
-----------------------------------------------------------------
Not a conceptual framework

"our work highlights the importance of.." No, you state that those things are important over and over, but you never make a good argument for it. In particular, you never ever state clearly -why it is important -what is it important for: that is, something is not good or bad in isolation. Something is good or bad instrumentally in order to reach a specific objective. What is the objective that you think is facilitated by having 'better more fluid programming environments'? You leave this implicit across the whole document!!

Section 1: "future programming systems will need to further..." Why? why will they need to do it? again, you do not "need to do" something in isolation. You need to do something in order to obtain or facilitate a goal. What is the goal here? I suspect once you state the goal I would be able to show you that it may not be the case.

So, "future programming systems will need to further..." is incomplete, the goal must be added, but even when the goal is added, this statement must be clearly labelled as an OPINION. I suspect it would be a widely agreed upon opinion, but an opinion; not a fact.

"will also need to transcend.." Again, add goal and flag as OPINION

"While we are firmly convinced that... are the future of programming" So much is implicit here. Do you think this is the future in the sense that you think is good and you think it will happen? Do you think it is the future because you hate it, but you still think it is going to be unavoidable? Do you think it will happen independently of your research work, or that it will happen because of your research work? There are 10 other possible interpretations for this sentence.

Just before 2.2 I think here you need to set expectations for correct local transformations, because no general solution exists, only conventions and expectations. Please, add numbers to those expectations, show examples of corner cases where stuff breaks and is an acceptable evil, and cases were stuff breaks on purpose (in some sense, and intended evil) To make an example: Java is of course not truly "cross-platform": if you wanted to put a formal definition to cross platform, the program should work identically in all environments. This would imply that the program should not be able to discover it's running environment. In Java I can make an 'if' at the beginning of the main and throw error on Windows. This makes Java not truly "cross-platform" in a logical sense, but this is often considered desirable.

In the context of those data transformations, there must be plenty of situations like that, where a change in behavior is not only possible or acceptable, but even desirable. However, we should have some clear formal definition of when/how/why such changes in behavior are introduced.

pg 7: "the key requirement.... do minimal harm" This is an Opinion + Industry convention.

"not commonly supported in data APIs" Define what a data API is and add a citation.

pg 10: "when applying code migrations, the system should minimize... the need for developer -written code" Again, "should" requires an explicit objective we are working toward. Plus, even after you add the objective, this still need to be labelled as an Opinion.

pg 13: Here I'm starting to wonder why you use this model at all. Once we accept that code can be changed and updated, the difference between data and code disappear. We could simply represent all data as hard coded instructions recreating such data. This may produce a much more cohesive mental model for the problem at hand. For example in this new model programs are able to 'restart' and when they restart they will execute this code 'pre-loading' the data in the state it was when the program was terminated.

Once code can be updated, data is just another kind of code. This requires a language where it is easy to declaratively describe any kind of arbitrary reachable object graphs, including circular ones.

Pg 16: "Live programming must move.... affordances" This is again an Opinion, and again 'must' can not exists alone, it needs a GOAL we are trying to obtain. You may think that such goal is really 'obvious', but it is not. What kind of programming you want to facilitate? why you want to facilitate that kind of programming? that kind of programming would in turn facilitate certain human endeavors but maybe not others, and the results may be very hard to predict and quite chaotic.

Pg 18: "no silver bullet to navigate... a good solution... tradeoffs" This assume no perverse incentives. Consider that if an operation is easier such operation will be done more often, and by sloppier and less skilled operators. Assuming the operators will be competent and will care about what they are doing is unrealistic.


Reviewer B
-----------------------------------------------------------------

[Types]

The concept of types as used in the paper was introduced too late (p. 3). And their definition (“we refer to the more fundamental layer as types, although we do not use the term in a precise technical sense”) was surprising, certainly from the point of view of the programming languages community. The “types” referred to in the paper felt closer to schemas / schema definitions (classic data types) than the more mathematical/logical foundations formulated in type systems. Maybe you can try to avoid or at least reduce this potential for confusion by using a different (better?) name. “Schema” might be a good start…

[Problems/Solutions]

I think that the submission being mainly about challenge problems and not about their solution(s) is important to (as mentioned in the abstract) allow the community explore the solution space themselves.

[Collaboration / Local-first]

I liked the discussion of both local/singular and collaborative development and the problems associated with them. And I would have liked to see those two situations discussed separately, because of their technical complexity and also the processes (people) causing them.

The placement of “local-first” felt like it didn’t help me understanding the problem. Maybe you can revisit the intent of those references. My preference would be try without them.

[Structure / Pattern Language]

While re-reading the submission, I noticed quite a similarity to a pattern language (in the sense of Christopher Alexander and/or the software patterns community). All sections covering a challenge problem present the context in which the problems occurs, describe the problem, and provide an example illustrating the problem to better relate to it. Also, they cross-reference other related challenge problems. The only obvious part that is missing (on purpose, see above) is a generative solution.

However, even though those elements are all present to a varying extent, the guiding structure of a pattern and their interconnection through a pattern language might be helpful but is missing. I strongly believe that transforming the material from a simple collection of problems into a pattern-language-like (the “like” because of the missing generative solutions) artifact would be helpful not only for the readers but the community helping provide those generative solutions and extending the (such) system of patterns…

[Literature Review]

To me, this was the weak spot of the submission. While I appreciate the links to related work, I was hoping for a description of (or reference to) the method(s) used to carry out the review. There are certainly several ways to address this. One of them might be to just provide that information. Another one might be to avoid “review” und discuss related work instead…


Reviewer C
-----------------------------------------------------------------

- Live Programming for the Elm Architecture

I agree with the presented arguments but have difficulty understanding the remarks about requirements and implementation. The authors say that the migration needs to be done automatically but do not suggest a solution to the problem. Is it a type-based program synthesis? Generation of lenses? In what scenario does it need to be done automatically? A more straightforward way (but maybe not what the authors were thinking) would be to ask the programmer to write the transformation function. So, what is the goal of the idealised system being thought over?

A reference like https://hazel.org/ should be referenced here.

- Entity Evolution in Data-centric Systems

In this case, the authors miss a classic reference to the problem of updatable views, which deal with the same category of issues when solving a different problem. Migrations here feel a lot like the back translation problem in updatable views.

Also, this is the most common type of evolution problem in the software industry, which is treated by disciplining the software process, versioning, and creating adapters. A contrast with these solutions, pointing again to the ghost system, would be very welcome. This approach is presented in section 6, but it makes sense to refer here as well.

https://www.irisa.fr/lande/lande/icse-proceedings/seams/p86.pdf

- Evolution of Computational Documents

This is a problem that existing approaches solve relatively well, and there is work using, for instance, operation-based CRDTs to solve the problem of collaborative editing and ensure eventual consistency. I think those solutions should be referred to, and their results should be compared to the goals presented in this section.

- Divergence control in Spreadsheets

The problem in this use case is broader than spreadsheets, and the section title may be misleading. Versioning schemes, like semantic versioning or language-based versioning, could solve the problem of divergence control in spreadsheets. This class of solutions could help present this case better.

https://dl.acm.org/doi/10.1145/3479394.3479416
Multiplicity Change in Data Formats (Migrations)

Using lenses to solve this problem would be a very good idea to highlight here, as in some old work of Benjamin Pierce and a system called Unison. This problem was central in transformations and sync operations in XML documents. I have no specific reference to point out, but Unison seems a good place to start. The synthesis of lenses can be done.

- Live Modelling Languages

This case study is, in my opinion, the more solid one in terms of presentation. It almost seems that this is the idealised system that the authors are thinking about. This presentation also gives away the identity of the authors (Programming is not double-blind; I am just referring to this since the authors omitted their names in the paper).

The comment about the presented example being out of reach for all existing language workbenches could be expanded to explain why. Are there any techniques extracted from the remaining case studies that would be useful here?

- Overall

the discussion and conclusions are very brief both at the end and in each case study and do not provide a clear path to solving the challenges presented in the paper. Even a speculative section pointing to combining features from different systems would be welcome to communicate the authors' vision of the future of interactive programming systems.


Meta-review
-----------------------------------------------------------------
Please revise this paper to satisfy the following suggestions:

- clarify if the paper targets a concrete tool under development, present it, and link it to the different aspects
- Make sure that all aspects are related to concrete tools, or explicitly saying that it is not possible or only in research prototypes
- Include an explicitly speculative section when tools do not exist, or the authors want to share some ideas for the future. The authors should take the more detailed changes into account as well.